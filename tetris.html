# Create a self-contained Tetris game as a single HTML file
<!DOCTYPE html>
<html lang="fr">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Tetris - Jouable maintenant</title>
<style>
  html,body{height:100%;margin:0;font-family:system-ui,-apple-system,Segoe UI,Roboto,Ubuntu,Cantarell,Arial,sans-serif;background:#111;color:#eee}
  .wrap{display:flex;flex-direction:column;align-items:center;justify-content:flex-start;gap:8px;padding:12px}
  canvas{background:#111;box-shadow:0 0 0 2px #333 inset;width:min(92vw,420px);height:calc(min(92vw,420px)*2)}
  .topbar{display:flex;gap:16px;align-items:center;justify-content:center;flex-wrap:wrap}
  .panel{background:#1a1a1a;border:1px solid #333;padding:8px 10px;border-radius:8px;min-width:120px}
  .panel h3{margin:0 0 6px 0;font-size:14px;color:#9bd}
  .panel .val{font-weight:700;font-size:18px}
  .controls{display:flex;gap:8px;flex-wrap:wrap;align-items:center;justify-content:center;margin-top:6px}
  button{background:#222;border:1px solid #444;color:#eee;padding:8px 10px;border-radius:8px;cursor:pointer}
  button:active{transform:translateY(1px)}
  .mobile{display:none}
  .hint{font-size:13px;opacity:.8}
  @media (max-width:700px){
    .mobile{display:flex}
  }
</style>
</head>
<body>
<div class="wrap">
  <div class="topbar">
    <div class="panel">
      <h3>Score</h3>
      <div id="score" class="val">0</div>
    </div>
    <div class="panel">
      <h3>Niveau</h3>
      <div id="level" class="val">1</div>
    </div>
    <div class="panel">
      <h3>Lignes</h3>
      <div id="lines" class="val">0</div>
    </div>
    <div class="panel">
      <h3>Prochain</h3>
      <canvas id="next" width="80" height="80" style="width:80px;height:80px;background:#111"></canvas>
    </div>
  </div>

  <canvas id="board" width="200" height="400"></canvas>

  <div class="controls">
    <button id="btn-left" aria-label="Gauche">◀</button>
    <button id="btn-rotate" aria-label="Rotation">⟳</button>
    <button id="btn-right" aria-label="Droite">▶</button>
    <button id="btn-down" aria-label="Bas">▼</button>
    <button id="btn-drop" aria-label="Chute">⤓</button>
    <button id="btn-pause" aria-label="Pause">Pause</button>
  </div>
  <div class="hint">Clavier: fleches pour bouger, Haut pour tourner, Espace pour chute rapide, C pour hold, P pour pause. R pour recommencer.</div>
</div>

<script>
(function(){
  const COLS = 10, ROWS = 20, BLOCK = 20;
  const canvas = document.getElementById("board");
  const ctx = canvas.getContext("2d");
  const nextCanvas = document.getElementById("next");
  const nctx = nextCanvas.getContext("2d");
  const scoreEl = document.getElementById("score");
  const levelEl = document.getElementById("level");
  const linesEl = document.getElementById("lines");
  canvas.width = COLS * BLOCK;
  canvas.height = ROWS * BLOCK;

  const colors = {
    I:"#00f0f0", J:"#0000f0", L:"#f0a000", O:"#f0f000",
    S:"#00f000", T:"#a000f0", Z:"#f00000", X:"#222"
  };

  const SHAPES = {
    I:[[0,0,0,0],[1,1,1,1],[0,0,0,0],[0,0,0,0]],
    J:[[1,0,0],[1,1,1],[0,0,0]],
    L:[[0,0,1],[1,1,1],[0,0,0]],
    O:[[1,1],[1,1]],
    S:[[0,1,1],[1,1,0],[0,0,0]],
    T:[[0,1,0],[1,1,1],[0,0,0]],
    Z:[[1,1,0],[0,1,1],[0,0,0]]
  };
  const PIECES = Object.keys(SHAPES);

  function rotate(m){
    const N = m.length;
    const res = Array.from({length:N},()=>Array(N).fill(0));
    for(let y=0;y<N;y++) for(let x=0;x<N;x++) res[x][N-1-y]=m[y][x];
    return res;
  }

  function clone(m){ return m.map(r=>r.slice()); }

  function rngBag(){
    let bag = PIECES.slice();
    let out = [];
    while(bag.length){
      const i = Math.floor(Math.random()*bag.length);
      out.push(bag.splice(i,1)[0]);
    }
    return out;
  }

  const board = Array.from({length:ROWS},()=>Array(COLS).fill(""));
  let queue = rngBag();
  let hold = null, holdUsed = false;
  let piece = null, pos = {x:3,y:0}, matrix = null, color = "", ghostY = 0;
  let score=0, level=1, lines=0;
  let dropCounter = 0, dropInterval = 1000;
  let last = performance.now();
  let paused = false;
  let gameOver = false;

  function newPiece(type){
    piece = type || nextPiece();
    matrix = clone(SHAPES[piece]);
    while(matrix.length<4) matrix.push(Array(matrix[0].length).fill(0));
    color = colors[piece];
    pos.x = Math.floor((COLS - matrix[0].length)/2);
    pos.y = 0;
    holdUsed = false;
    if(collide()) { gameOver = true; paused = true; draw(); }
  }

  function nextPiece(){
    if(queue.length===0) queue = rngBag();
    const p = queue.shift();
    drawNext();
    return p;
  }

  function drawNext(){
    nctx.clearRect(0,0,nextCanvas.width,nextCanvas.height);
    const upcoming = queue.length ? queue[0] : PIECES[Math.floor(Math.random()*PIECES.length)];
    const m = SHAPES[upcoming];
    const size = 16;
    const ox = Math.floor((nextCanvas.width - m[0].length*size)/2);
    const oy = Math.floor((nextCanvas.height - m.length*size)/2);
    for(let y=0;y<m.length;y++) for(let x=0;x<m[y].length;x++){
      if(m[y][x]){
        nctx.fillStyle = colors[upcoming];
        nctx.fillRect(ox+x*size, oy+y*size, size-1, size-1);
      }
    }
  }

  function collide(px=pos.x, py=pos.y, m=matrix){
    for(let y=0;y<m.length;y++){
      for(let x=0;x<m[y].length;x++){
        if(!m[y][x]) continue;
        const nx = px+x, ny = py+y;
        if(nx<0 || nx>=COLS || ny>=ROWS) return true;
        if(ny>=0 && board[ny][nx]) return true;
      }
    }
    return false;
  }

  function merge(){
    for(let y=0;y<matrix.length;y++){
      for(let x=0;x<matrix[y].length;x++){
        if(matrix[y][x] && pos.y+y>=0) board[pos.y+y][pos.x+x] = piece;
      }
    }
  }

  function clearLines(){
    let cleared = 0;
    outer: for(let y=ROWS-1;y>=0;y--){
      for(let x=0;x<COLS;x++){
        if(!board[y][x]) { continue outer; }
      }
      board.splice(y,1);
      board.unshift(Array(COLS).fill(""));
      cleared++; y++;
    }
    if(cleared){
      const points = [0,40,100,300,1200][cleared] * level;
      score += points;
      lines += cleared;
      if(lines >= level*10){ level++; dropInterval = Math.max(100, 1000 - (level-1)*80); }
      updateHUD();
    }
  }

  function updateHUD(){
    scoreEl.textContent = String(score);
    levelEl.textContent = String(level);
    linesEl.textContent = String(lines);
  }

  function hardDrop(){
    while(!collide(pos.x,pos.y+1)) pos.y++;
    tickDown();
  }

  function holdSwap(){
    if(holdUsed) return;
    const cur = piece;
    if(hold==null){
      hold = cur;
      newPiece();
    }else{
      const tmp = hold; hold = cur;
      newPiece(tmp);
    }
    holdUsed = true;
  }

  function move(dx){
    if(paused||gameOver) return;
    if(!collide(pos.x+dx,pos.y)) pos.x+=dx;
  }

  function rotatePiece(){
    if(paused||gameOver) return;
    const r = rotate(matrix);
    // simple wall kicks
    const kicks = [0,-1,1,-2,2];
    for(const k of kicks){
      if(!collide(pos.x+k, pos.y, r)){ matrix = r; pos.x += k; return; }
    }
  }

  function tickDown(){
    if(paused||gameOver) return;
    if(!collide(pos.x,pos.y+1)){
      pos.y++;
    }else{
      merge();
      clearLines();
      newPiece();
    }
  }

  function drawBlock(x,y,t){
    ctx.fillStyle = t ? colors[t] : "#222";
    ctx.fillRect(x*BLOCK,y*BLOCK,BLOCK-1,BLOCK-1);
  }

  function computeGhostY(){
    let gy = pos.y;
    while(!collide(pos.x, gy+1)) gy++;
    return gy;
  }

  function draw(){
    ctx.clearRect(0,0,canvas.width,canvas.height);
    for(let y=0;y<ROWS;y++){
      for(let x=0;x<COLS;x++){
        const t = board[y][x];
        if(t) drawBlock(x,y,t);
        else {
          ctx.fillStyle = (x%2==y%2) ? "#121212" : "#101010";
          ctx.fillRect(x*BLOCK,y*BLOCK,BLOCK-1,BLOCK-1);
        }
      }
    }
    if(!gameOver){
      ghostY = computeGhostY();
      // ghost
      ctx.globalAlpha = 0.2;
      for(let y=0;y<matrix.length;y++) for(let x=0;x<matrix[y].length;x++){
        if(matrix[y][x]){
          ctx.fillStyle = color;
          ctx.fillRect((pos.x+x)*BLOCK,(ghostY+y)*BLOCK,BLOCK-1,BLOCK-1);
        }
      }
      ctx.globalAlpha = 1;
      // piece
      for(let y=0;y<matrix.length;y++) for(let x=0;x<matrix[y].length;x++){
        if(matrix[y][x]) drawBlock(pos.x+x,pos.y+y,piece);
      }
    }else{
      ctx.fillStyle = "rgba(0,0,0,0.6)";
      ctx.fillRect(0,0,canvas.width,canvas.height);
      ctx.fillStyle = "#fff";
      ctx.textAlign = "center";
      ctx.font = "20px Arial";
      ctx.fillText("Game Over", canvas.width/2, canvas.height/2 - 10);
      ctx.font = "14px Arial";
      ctx.fillText("Appuie sur R pour rejouer", canvas.width/2, canvas.height/2 + 16);
    }
  }

  function loop(now){
    const dt = now - last; last = now;
    if(!paused && !gameOver){
      dropCounter += dt;
      if(dropCounter > dropInterval){ dropCounter = 0; tickDown(); }
    }
    draw();
    requestAnimationFrame(loop);
  }

  function start(){
    score=0; level=1; lines=0; updateHUD();
    for(let y=0;y<ROWS;y++) for(let x=0;x<COLS;x++) board[y][x] = "";
    queue = rngBag();
    hold = null; holdUsed = false;
    paused=false; gameOver=false;
    dropInterval = 1000;
    newPiece();
    drawNext();
    last = performance.now();
    requestAnimationFrame(loop);
  }

  // input
  document.addEventListener("keydown", e=>{
    if(e.repeat) return;
    if(e.code==="ArrowLeft") move(-1);
    else if(e.code==="ArrowRight") move(1);
    else if(e.code==="ArrowDown") tickDown();
    else if(e.code==="ArrowUp") rotatePiece();
    else if(e.code==="Space") hardDrop();
    else if(e.key==="c" || e.key==="C") holdSwap();
    else if(e.key==="p" || e.key==="P") { paused=!paused; }
    else if(e.key==="r" || e.key==="R") { start(); }
  });

  // mobile buttons
  function bind(id,fn){ document.getElementById(id).addEventListener("click", fn); }
  bind("btn-left", ()=>move(-1));
  bind("btn-right", ()=>move(1));
  bind("btn-rotate", ()=>rotatePiece());
  bind("btn-down", ()=>tickDown());
  bind("btn-drop", ()=>hardDrop());
  bind("btn-pause", ()=>{ paused=!paused; });

  start();
})();
</script>
</body>
</html>